rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is the owner
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if the current user is an admin
    function isAdmin() {
      return isAuthenticated() && request.auth != null && (
        request.auth.token.email in ['admin@ustp.edu.ph', 'superadmin@ustp.edu.ph', 'admin@uniclaim.com', 'cs@uniclaim.com'] ||
        (request.auth.token.role == 'admin')
      );
    }
    
    // Check if the current user is a new user (not yet email verified)
    function isNewUser() {
      return isAuthenticated() &&
        request.auth != null &&
        request.auth.token.email_verified == false;
    }
    
    // Check if the current user is banned
    function isUserBanned() {
      return isAuthenticated() &&
        request.auth != null &&
        request.auth.token.status in ['deactivated', 'banned'];
    }
    

    // Users collection - only for verified users
    match /users/{userId} {
      // Users can read their own data, admins can read all
      // Also allow querying users by email for admin status checks
      allow read: if isAuthenticated() && (
        resource.data.emailVerified == true || 
        isAdmin() || 
        resource.data.role in ['admin', 'campus_security'] ||
        // Allow reading basic user info for messaging (when querying with limit)
        (request.query.limit != null && int(request.query.limit) <= 20) ||
        // Allow querying users by email for admin status checks
        (request.query['email'] != null && 
         (request.query['email'] is string || 
          (request.query['email'] is list && request.query['email'].size() <= 10)))
      );

      // Users can update their own data, admins can update any
      allow update: if isAuthenticated() && (
        isOwner(userId) || 
        isAdmin()
      );

      // Allow push token updates for authenticated users (for notification setup)
      allow update: if isAuthenticated() && isOwner(userId) &&
        (resource.data.status == null || (resource.data.status != 'deactivated' && resource.data.status != 'banned')) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pushToken', 'pushTokenUpdatedAt']);
        
      // Allow profile updates for authenticated users (for profile editing)
      // Users can update their basic profile information
      allow update: if isAuthenticated() && isOwner(userId);
      
      // Allow users to delete their own document (for account deletion)
      allow delete: if isAuthenticated() && isOwner(userId);
    }

    // Posts collection rules
    match /posts/{postId} {
      // Allow authenticated users to read posts
      allow read: if isAuthenticated();

      // Allow users to create posts if they're authenticated and not banned
      allow create: if isAuthenticated() && !isUserBanned();

      // Allow users to update their own posts, or admins can update any post
      // Allow new users to update their posts before email verification
      allow update: if isAuthenticated() && 
        (resource.data.user.email.lower() == request.auth.token.email.lower() || 
         isAdmin() || 
         isNewUser());

      // Users can delete their own posts, or admins can delete any post
      // Allow new users to delete their own posts
      allow delete: if isAuthenticated() && 
        (resource.data.user.email.lower() == request.auth.token.email.lower() || 
         isAdmin() || 
         isNewUser());
    }
    
    // Conversations collection for messaging
    match /conversations/{conversationId} {
      // Helper function to check if user is a participant (supports both array and object formats)
      function isConversationParticipant() {
        return isAuthenticated() && (
          // Check if user is an admin
          isAdmin() ||
          // Check if user is a participant in the existing document
          (resource != null && resource.data != null && (
            (resource.data.participants is map && resource.data.participants[request.auth.uid] == true) ||
            (resource.data.participants is list && resource.data.participants.hasAny([request.auth.uid])) ||
            (resource.data.participantInfo is map && resource.data.participantInfo[request.auth.uid] != null)
          )) ||
          // Check if user is being added as a participant in the new document
          (request.resource != null && request.resource.data != null && (
            (request.resource.data.participants is map && request.resource.data.participants[request.auth.uid] == true) ||
            (request.resource.data.participants is list && request.resource.data.participants.hasAny([request.auth.uid])) ||
            (request.resource.data.participantInfo is map && request.resource.data.participantInfo[request.auth.uid] != null)
          ))
        );
      }

      // Allow listing conversations where the user is a participant
      allow list: if isAuthenticated() && (
        // User can list if they're an admin
        isAdmin() ||
        // Or if they're querying with a participant filter that includes their ID
        (request.query != null && 
         request.query.where != null && 
         (
           // Allow querying by participantIds array
           (request.query.where.field == 'participantIds' &&
            request.query.where.op == 'array-contains' &&
            request.query.where.value == request.auth.uid) ||
           // Backward compatibility with old queries
           (request.query.where.field == 'participants.' + request.auth.uid &&
            request.query.where.op == '==' &&
            request.query.where.value == true) ||
           (request.query.where.field == 'participantInfo.' + request.auth.uid &&
            request.query.where.op == '!=' &&
            request.query.where.value == null)
         ))
      );
      
      // Allow listing all conversations if user is admin (without filtering)
      allow list: if isAdmin();
      
      // Allow getting a specific conversation if user is a participant
      allow get: if isConversationParticipant();
      
      // Allow creating conversations if the user is included in participants
      allow create: if isAuthenticated() && (
        // User is an admin
        isAdmin() ||
        // Or user is included in the participants map
        (request.resource.data.participants is map && 
         request.resource.data.participants[request.auth.uid] == true) ||
        // Or user is included in the participants list (legacy support)
        (request.resource.data.participants is list && 
         request.resource.data.participants.hasAny([request.auth.uid])) ||
        // Or user is included in the participantInfo map
        (request.resource.data.participantInfo is map && 
         request.resource.data.participantInfo[request.auth.uid] != null)
      ) && (
        // Ensure the postId is provided
        request.resource.data.postId != null &&
        // Ensure the postOwnerId is provided and matches one of the participants
        request.resource.data.postOwnerId != null &&
        (
          (request.resource.data.participants[request.resource.data.postOwnerId] == true) ||
          (request.resource.data.participantInfo[request.resource.data.postOwnerId] != null)
        )
      );
      
      // Allow updating lastMessage and updatedAt fields
      allow update: if isConversationParticipant() && (
        // Only allow updating specific fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'updatedAt']) ||
        // Or allow updating readBy array
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy']) &&
         request.auth.uid in request.resource.data.readBy)
      );
      
      // Messages subcollection rules
      match /messages/{messageId} {
        // Helper function to check if user is a participant in the parent conversation
        function isParentConversationParticipant() {
          return isAuthenticated() && (
            // Get the parent conversation document
            get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants[request.auth.uid] == true ||
            isAdmin()
          );
        }
        
        // Allow reading messages if user is a conversation participant
        allow read: if isParentConversationParticipant();
        
        // Allow creating messages if user is a conversation participant
        allow create: if isParentConversationParticipant() && 
          request.resource.data.senderId == request.auth.uid &&
          request.resource.data.timestamp == request.time;
          
        // Allow updating only specific fields (like read status)
        allow update: if isParentConversationParticipant() && (
          // Allow updating readBy array
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy']) &&
           request.auth.uid in request.resource.data.readBy) ||
          // Allow sender to update their own messages within a short time window
          (resource.data.senderId == request.auth.uid &&
           request.time < resource.data.timestamp + duration.value(5, 'm'))
        );
      }
    }

    // Admin notifications collection
    match /admin_notifications/{notificationId} {
      // Allow admins to list and read their own notifications or broadcast notifications
      allow list, read: if isAuthenticated() && isAdmin() && (
        // Allow reading notifications for the current admin or broadcast notifications
        resource.data.adminId == request.auth.uid || 
        resource.data.adminId == 'all' ||
        // Allow querying by adminId
        (request.query != null && request.query.where != null && 
         request.query.where.fieldPath == 'adminId' && 
         (request.query.where.op == '==' && request.query.where.value == request.auth.uid))
      );
      
      // Allow creating notifications for admins
      allow create: if isAuthenticated() && isAdmin() && (
        // Validate required fields
        request.resource.data.keys().hasAll(['title', 'message', 'adminId', 'type', 'createdAt']) &&
        // Ensure adminId is either 'all' or matches the current user's ID
        (request.resource.data.adminId == 'all' || request.resource.data.adminId == request.auth.uid)
      );
      
      // Allow updating notifications (e.g., marking as read)
      allow update: if isAuthenticated() && isAdmin() && (
        // Only allow updating specific fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt', 'updatedAt']) &&
        // Only allow updating your own notifications or broadcast notifications
        (resource.data.adminId == request.auth.uid || resource.data.adminId == 'all')
      );
      
      // Allow deleting notifications
      allow delete: if isAuthenticated() && isAdmin() && (
        // Only allow deleting your own notifications or broadcast notifications
        resource.data.adminId == request.auth.uid || 
        resource.data.adminId == 'all'
      );
    }

    // User notifications collection
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow list, read: if isAuthenticated() && (
        // Direct document access
        resource.data.userId == request.auth.uid ||
        // Query access (for list operations)
        (request.query != null && 
         request.query.where != null && 
         request.query.where.fieldPath == 'userId' && 
         request.query.where.op == '==' && 
         request.query.where.value == request.auth.uid) ||
        // Collection group query support
        (request.query != null && 
         request.query.collectionGroup == 'notifications' &&
         request.query.where != null &&
         request.query.where.fieldPath == 'userId' &&
         request.query.where.op == '==' &&
         request.query.where.value == request.auth.uid)
      );
      
      // Allow creating notifications
      allow create: if isAuthenticated() && (
        // User can only create notifications for themselves
        request.resource.data.userId == request.auth.uid &&
        // Required fields must be present
        request.resource.data.keys().hasAll(['userId', 'title', 'message', 'type', 'createdAt']) &&
        // Type must be one of the allowed types
        request.resource.data.type in ['new_post', 'message', 'claim_update', 'admin_alert', 
                                     'conversation_deleted', 'claim_response', 'handover_response', 
                                     'status_change', 'post_activated', 'post_reverted', 
                                     'post_deleted', 'post_restored']
      );
      
      // Allow updating read status and readAt timestamp
      allow update: if isAuthenticated() && (
        // User can only update their own notifications
        resource.data.userId == request.auth.uid &&
        // Only allow updating specific fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']) &&
        // Ensure userId cannot be changed
        request.resource.data.userId == resource.data.userId
      );
      
      // Allow deleting notifications
      allow delete: if isAuthenticated() && (
        // User can only delete their own notifications
        resource.data.userId == request.auth.uid
      );
    }
    
    // Allow collection group queries on notifications
    match /{path=**}/notifications/{notificationId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid
      );
    }

    // Admin notification preferences
    match /adminNotificationPreferences/{adminId} {
      // Allow admins to read and update their own preferences
      allow read: if isAuthenticated() && (isAdmin() && isOwner(adminId));
      allow create, update: if isAuthenticated() && (isAdmin() && isOwner(adminId));
    }
  }
}